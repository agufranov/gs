// deno-fmt-ignore-file
import { IsLocalizedValidationError } from '../../error/index.mjs';
import { Guard } from '../../guard/index.mjs';
import { IsKind } from './schema.mjs';
// ------------------------------------------------------------------
// BaseNotImplemented
// ------------------------------------------------------------------
export class BaseNotImplemented extends Error {
    constructor(type, method) {
        super(`Base type does not implement the '${method}' function`);
        Object.defineProperty(this, 'cause', {
            value: { type, method },
            writable: false,
            configurable: false,
            enumerable: false
        });
    }
}
// ------------------------------------------------------------------------------------
// BaseValidator
// ------------------------------------------------------------------------------------
class BaseValidator {
    constructor(check, errors) {
        this.check = check;
        this.errors = errors;
        this.vendor = 'typebox';
        this.version = 1;
        this.validate = (value) => {
            return this.check(value)
                ? this.Success(value)
                : this.Failure(this.errors(value));
        };
    }
    Success(value) {
        return { value };
    }
    Failure(errors) {
        const issues = errors.reduce((result, error) => [...result, ...CreateIssues(error)], []);
        return { issues };
    }
}
// ------------------------------------------------------------------
// Type
// ------------------------------------------------------------------
/** Base class for creating extension types. */
export class Base {
    constructor() {
        const validator = new BaseValidator((value) => this.Check(value), (value) => this.Errors(value));
        const configuration = {
            writable: false,
            configurable: false,
            enumerable: false
        };
        Object.defineProperty(this, '~kind', { ...configuration, value: 'Base' });
        Object.defineProperty(this, '~standard', { ...configuration, value: validator });
    }
    /** Checks a value or returns false if invalid */
    Check(value) {
        return true;
    }
    /** Returns errors for a value. Return an empty array if valid.  */
    Errors(value) {
        return [];
    }
    /** Converts a value into this type */
    Convert(value) {
        return value;
    }
    /** Cleans a value according to this type */
    Clean(value) {
        return value;
    }
    /** Returns a default value for this type */
    Default(value) {
        return value;
    }
    /** Creates a new instance of this type */
    Create() {
        throw new BaseNotImplemented(this, 'Create');
    }
}
// ------------------------------------------------------------------
// Guard
// ------------------------------------------------------------------
/** Returns true if the given value is a Base type. */
export function IsBase(value) {
    return IsKind(value, 'Base');
}
// --------------------------------------------------------
// StandardSchema: PathSegments
// --------------------------------------------------------
function PathSegments(pointer) {
    if (Guard.IsEqual(pointer.length, 0))
        return [];
    return pointer.slice(1).split("/").map(segment => segment.replace(/~1/g, "/").replace(/~0/g, "~"));
}
// --------------------------------------------------------
// IsStandardSchemaV1Error
// --------------------------------------------------------
function IsStandardSchemaV1Error(error) {
    return Guard.IsEqual(error.keyword, '~standard');
}
// --------------------------------------------------------
// IssuesFromLocalizedError
// --------------------------------------------------------
function IssuesFromStandardSchemaV1Error(error) {
    const leading = PathSegments(error.instancePath);
    const issues = Guard.IsArray(error.params.issues) ? error.params.issues : [];
    return issues.map(issue => {
        const message = Guard.IsString(issue.message) ? issue.message : 'unknown';
        const path = Guard.IsArray(issue.path) ? [...leading, ...issue.path] : leading;
        return { message, path };
    });
}
function IssuesFromRegularError(error) {
    const path = PathSegments(error.instancePath);
    return [{ path, message: error.message }];
}
function IssuesFromLocalizedError(error) {
    return IsStandardSchemaV1Error(error)
        ? IssuesFromStandardSchemaV1Error(error)
        : IssuesFromRegularError(error);
}
// --------------------------------------------------------
// IssuesFromUnknown
// --------------------------------------------------------
function IssuesFromUnknown(error) {
    const path = Guard.HasPropertyKey(error, 'path') && Guard.IsArray(error.path) && error.path.every(segment => Guard.IsString(segment)) ? error.path : [];
    const message = Guard.HasPropertyKey(error, 'message') && Guard.IsString(error.message) ? error.message : 'unknown';
    return [{ path, message }];
}
// --------------------------------------------------------
// CreateIssues
// --------------------------------------------------------
function CreateIssues(error) {
    return IsLocalizedValidationError(error)
        ? IssuesFromLocalizedError(error)
        : IssuesFromUnknown(error);
}
