import { type TSchema } from './schema.mjs';
export declare class BaseNotImplemented extends Error {
    readonly cause: {
        type: Base;
        method: string;
    };
    constructor(type: Base, method: string);
}
/** Base class for creating extension types. */
export declare class Base<Value extends unknown = unknown> implements TSchema {
    readonly '~kind': 'Base';
    readonly '~standard': StandardSchemaV1.Props<Value>;
    constructor();
    /** Checks a value or returns false if invalid */
    Check(value: unknown): value is Value;
    /** Returns errors for a value. Return an empty array if valid.  */
    Errors(value: unknown): object[];
    /** Converts a value into this type */
    Convert(value: unknown): unknown;
    /** Cleans a value according to this type */
    Clean(value: unknown): unknown;
    /** Returns a default value for this type */
    Default(value: unknown): unknown;
    /** Creates a new instance of this type */
    Create(): Value;
}
/** Returns true if the given value is a Base type. */
export declare function IsBase(value: unknown): value is Base;
interface StandardSchemaV1<Input = unknown, Output = Input> {
    readonly '~standard': StandardSchemaV1.Props<Input, Output>;
}
declare namespace StandardSchemaV1 {
    export interface Props<Input = unknown, Output = Input> {
        readonly version: 1;
        readonly vendor: string;
        readonly validate: (value: unknown) => Result<Output> | Promise<Result<Output>>;
        readonly types?: Types<Input, Output> | undefined;
    }
    export type Result<Output> = SuccessResult<Output> | FailureResult;
    export interface SuccessResult<Output> {
        readonly value: Output;
        readonly issues?: undefined;
    }
    export interface FailureResult {
        readonly issues: ReadonlyArray<Issue>;
    }
    export interface Issue {
        readonly message: string;
        readonly path?: ReadonlyArray<PropertyKey | PathSegment> | undefined;
    }
    export interface PathSegment {
        readonly key: PropertyKey;
    }
    export interface Types<Input = unknown, Output = Input> {
        readonly input: Input;
        readonly output: Output;
    }
    export type InferInput<Schema extends StandardSchemaV1> = NonNullable<Schema['~standard']['types']>['input'];
    export type InferOutput<Schema extends StandardSchemaV1> = NonNullable<Schema['~standard']['types']>['output'];
    export {};
}
export {};
